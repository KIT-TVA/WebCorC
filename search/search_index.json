{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The CorC Ecosystem: Tool Support for by-Construction Engineering","text":"<p>News: Our new wiki and documentation is online!</p> <p>Functional correctness is a central aspect of every software system. Software development approaches based on test cases are a fast and reliable way to show that the tested parts of a software system function as intended. However, testing only gives partial correctness guarantees, as the absence of bugs cnnot be shown. Formal verification on contrast can prove that a software is working as intended w.r.t. its formal specification.</p> <p>Post-hoc approaches ensuring functional correctness after implementing a software are common techniques to prove a software correct. Correctness-by-Construction (CbC) instead offers correctness guarantees already during program construction and, thus, enables early detection and fixing of bugs.</p> <p>In CbC, using logical formulas, a program's contract formally specifies what it expects as input, denoted as precondition, and which outputs it produces, denoted as postcondition. Traditionally, once a program is implemented and specified, it is verified afterwards whether it fulfills its obligations according to its contract. In difference, the main idea in CbC is to guide developers in incrementally specifying and implementing a program. Stepwise specification and implementation enable the creation of correct programs by construction since each specification and implementation step can be verified individually.</p> <p>In recent years, the scope of CbC was extended to ensure secure information flow in CbC programs besides functional correctness. We refer to work in the field of non-functional properties in by-Construction engineering as X-by-Construction (XbC).</p>"},{"location":"#webcorc-and-corc-eclipse","title":"\ud83d\udee0\ufe0f WebCorC and CorC (Eclipse)","text":""},{"location":"corc/code-conversion/","title":"Code conversion","text":""},{"location":"corc/code-conversion/#code-to-cbc","title":"Code to CbC","text":"<p>Use the Code to CbC extension to generate a CbC program from plain Java code. The extension generates the corresponding diagram in the graphical editor. Following the creation of the diagram, we must provide missing conditions for the refinement rules. Use the extension by: 1. Select the Java source file. 2. Press the context menu option <code>Generate Diagrams from Class</code>. 3. Add additional conditions to the generated Java code using JML.</p>"},{"location":"corc/corc-overview/","title":"CorC","text":"<p>An eclipse-based CbC development environment that supports a plethora of features.</p>"},{"location":"corc/corc-overview/#extensions","title":"Extensions","text":"<p>The CorC ecosystem provides a plethora of extensions. We now list the most commonly used extensions. Most extensions not listed here are accessible through the context menu in CorC.</p> <p>-- from readme corc</p>"},{"location":"corc/corc-overview/#contribution","title":"Contribution","text":"<ol> <li>Create a fork.</li> <li>Create a new branch with a name that describes your new feature.</li> <li>Ensure that the command <code>mvn compile spotless:apply</code> runs successfully.</li> <li>Start a pull request.</li> </ol>"},{"location":"corc/corc-overview/#formatting","title":"Formatting","text":"<p>We use the default Eclipse formatting style with spotless. Run <code>mvn spotless:apply</code> to format all src files automatically if needed.</p>"},{"location":"corc/corc-overview/#examples-case-study-introduction","title":"Examples &amp; Case Study Introduction","text":"<p>We provide different examples and case studies to explore CorC!</p>"},{"location":"corc/corc-overview/#examples","title":"Examples","text":"<p>Create CorC-examples via <code>File -&gt; New -&gt; Other... -&gt; CorC -&gt; CorC Examples</code>.</p>"},{"location":"corc/corc-overview/#case-studies","title":"Case studies","text":"<p>The repository you checked out contains various software product line case studies in the folder <code>CaseStudies</code>. They can be loaded via <code>File -&gt; Open project from file system</code>. </p>"},{"location":"corc/corc-overview/#bankaccount","title":"BankAccount","text":"<p>The BankAccount implements basic functions of a bank account such as withdrawals, limits, money transfers and checking the account balance. - BankAccount Object-oriented implementation with class structure and CbC-Classes. - BankAccountOO Object-oriented implementation with class structure and CbC-Classes. Non-SPL implementation.</p>"},{"location":"corc/corc-overview/#elevator","title":"Elevator","text":"<p>The Elevator implements basic functions of an elevator such as the movement and entering and leaving of persons. - Elevator Object-oriented implementation with class structure and CbC-Classes.</p>"},{"location":"corc/corc-overview/#email","title":"Email","text":"<p>The product line Email implements basic functions of an email system including server- and client-side interactions. - EmailOO Object-oriented implementation with class structure and CbC-Classes. Non-SPL implementation. - EmailFeatureInteraction Java-Implementation without implementation with CbC.</p>"},{"location":"corc/corc-overview/#integerlist","title":"IntegerList","text":"<p>The IntegerList implements a list of integers with add and sort operations. - IntegerList Object-oriented implementation with class structure and CbC-Classes. - IntegerListOO Object-oriented implementation with class structure and CbC-Classes. Non-SPL implementation.</p>"},{"location":"corc/counterexamples/","title":"Counterexamples","text":""},{"location":"corc/counterexamples/#counterexample-generation","title":"Counterexample Generation","text":"<p>Our counterexample generation extension is another valuable tool for finding bugs in CbC programs. CorC uses Z3 to generate counterexamples for non-closeable proofs. To enable the generation of counterexamples: <code>View: Properties -&gt; Settings -&gt; Generate Counterexamples</code>. Once we activate this option, CorC provides a counterexample for every non-closeable proof, if possible. Note that Z3 uses special syntax to represent counterexamples. Their wiki provides more information.</p> <p>[[https://github.com/KIT-TVA/CorC/blob/master/Wiki/counterexample.png]]</p>"},{"location":"corc/editors/","title":"Editors","text":""},{"location":"corc/editors/#graphical-editor","title":"Graphical Editor","text":"<p>The graphical editor provides diagram elements to create CbC programs graphically. [[https://github.com/KIT-TVA/CorC/blob/master/Wiki/graphical-editor.png]]</p> <ul> <li>The white canvas contains the content of a CbC program, which in this case is called <code>graphical_editor</code>.</li> <li>The <code>Palette</code> contains all tools to manipulate the diagram, including all CorC refinements.</li> <li>The window tabs on the bottom are called <code>Eclipse property views</code>. These can be opened and closed on demand through <code>Window -&gt; Show View -&gt; Other...</code>.</li> </ul>"},{"location":"corc/editors/#textual-editor","title":"Textual Editor","text":"<p>In addition to the graphical editor, we provide a textual editor called LOST-Editor. The LOST-Editor is based on the LOST DSL and is accessible through the Eclipse property view (<code>Window -&gt; Show View -&gt; LOST-Editor</code>). In LOST, each line represents an operation or is part of Java code. A line followed by a tab indicates a new refinement. With this, we get a tree-like code structure in which the number of tabs represents the depth of the tree of a CorC diagram before each refinement. Developers specify refinements sequentially, starting from the abstract hoare triple and continuing through its refinements sequentially. LOST supports the same refinement rules as the graphical editor: - <code>F(pre: [preCondition], post: [postCondition])</code> - Formula with pre- and post-condition. - <code>C(intm: [intermediateCondition])</code> - Composition with its intermediate condition. - <code>S(guard: [guard1], guard: [guard2], ...)</code> - Selection statement and its guards. - <code>L(inv: [invariant], guard: [guard], var: [variant])</code> - Repetition statement (\"Loop\") and its invariant, guard, and variant. - <code>[statement] ;</code> - Basic statement. - <code>O: [statement] ;</code> - Original statement. Used in SPLs to refer to the definition of the parent of any given method. - <code>R: [statement] ;</code> - Return statement. - <code>M: [statement] ;</code> - Method call statement. - <code>skip</code> - Skip statement. - <code>{ [statements] }</code> - Block of Java code.</p> <p>Additionally, each refinement rule supports the specification of modifiables variables. Specify the initializer <code>mod: [modifiable]</code> as the first parameter of any refinement rule, e.g., <code>F(mod: x, pre: x &gt; 0, post: y &gt; 0)</code>. Further details are described in the LOST-documentation.</p>"},{"location":"corc/gettingstarted/","title":"\ud83e\ude90 CorC (Eclipse) - Getting Started","text":"<p>To use the Eclipse-version of CorC, follow the following guide for setup. The guide is validated for Windows setup.</p>"},{"location":"corc/gettingstarted/#java-version","title":"\u2668\ufe0f Java Version","text":"<p>Install JDK 21. CorC may not work out of the box with newer versions.</p>"},{"location":"corc/gettingstarted/#eclipse-modelling-tools-and-plugins","title":"\u2699\ufe0f Eclipse Modelling Tools and Plugins","text":"<ul> <li>Install Eclipse Modelling Tools (EMT) (Version 2024-03). CorC may not work out of the box with newer versions.</li> <li> <p>Get the latest release of Z3 and add the <code>*/z3-[cur-version]-[x64/x32]-win/bin</code> folder to the environment variable PATH</p> </li> <li> <p>Install Graphiti using the update site https://download.eclipse.org/graphiti/updates/release/0.18.0</p> </li> <li> <p>Install FeatureIDE which is available in Eclipse Marketplace</p> </li> <li> <p>Install Mylyn which is available in Eclipse Marketplace (Mylyn 3.23)</p> </li> <li> <p>Install TestNG which is available in Eclipse Marketplace</p> </li> </ul>"},{"location":"corc/gettingstarted/#corc-setup","title":"\ud83c\udf7e CorC Setup","text":"<ol> <li>Clone the repository:     <code>sh     git clone https://github.com/KIT-TVA/CorC.git</code></li> <li> <p>In EMT, select <code>Open Projects... -&gt; CorC</code> and check the boxes for the following packages:</p> <ul> <li><code>de.tu-bs.cs.isf.cbc.exceptions</code></li> <li><code>de.tu-bs.cs.isf.cbc.model</code></li> <li><code>de.tu-bs.cs.isf.cbc.mutation</code></li> <li><code>de.tu-bs.cs.isf.cbc.tool</code></li> <li><code>de.tu-bs.cs.isf.cbc.util</code></li> <li><code>de.tu-bs.cs.isf.cbcclass.tool</code></li> <li><code>de.tu-bs.cs.isf.wizards</code></li> <li><code>de.tu_bs.cs.isf.cbc.parser</code></li> <li><code>de.tu_bs.cs.isf.cbc.statistics</code></li> <li><code>de.tu_bs.cs.isf.cbc.statistics.ui</code></li> <li><code>de.tu_bs.cs.isf.commands.toolbar</code></li> <li><code>de.tu_bs.cs.isf.lattice</code></li> <li><code>de.tu_bs.cs.isf.proofrepository</code></li> <li><code>de.kit.tva.lost</code></li> </ul> </li> <li> <p>Open:</p> <ul> <li><code>*.cbc.model -&gt; model -&gt; genmodel.genmodel</code></li> <li><code>*.cbc.statistics -&gt; model -&gt; cbcstatistics.genmodel</code> </li> </ul> <p>Right click and <code>Generate Model/Edit/Editor Code</code> for all files listed. If EMT still displays errors, clean and rebuild all projects as described in the common issues section.</p> </li> <li> <p>Select any package and run project as <code>Eclipse Application</code>.</p> </li> </ol>"},{"location":"corc/gettingstarted/#getting-started-with-examples","title":"\ud83d\uddc4\ufe0f Getting Started with Examples","text":"<p>We provide a set of exemplary CbC-programs besides our case studies. Refer to case studies to learn what examples and case studies we offer and how to use them.</p>"},{"location":"corc/gettingstarted/#common-issues","title":"\ud83e\udee0 Common Issues","text":"<p>Problem: EMT gets stuck while trying to generate a model.</p> <p>Solution: Terminate EMT using any process manager and generate the model again.</p> <p>Problem: Multiple resolving errors after generating model files.</p> <p>Solution: Clean and rebuild all projects via <code>Project -&gt; Clean...</code>.</p> <p>Problem: Cycling depedency issues.</p> <p>Solution: Navigate to: <code>Project -&gt; Properties -&gt; Java Compiler -&gt; Building -&gt; Configure Workspace Settings -&gt; Build path problems -&gt; Circular dependencies</code> and set the listbox to <code>Warning</code>.</p> <p>Problem: Errors in certain files about undefined methods and classes.</p> <p>Solution: Changing the compliance: <code>Project -&gt; Java Compiler -&gt; JDK Complicance -&gt; Use compliance from execution environment 'JavaSE-16'</code>.</p> <p>Problem: Errors involving the message 'Cannot modify resource set without a write transaction'.</p> <p>Solution: Delete the folder <code>.settings</code> in <code>org.eclipse.core.runtime</code> within the current workspace. If that doesn't resolve the issue, delete all <code>.settings</code> folders and the <code>.project</code> file in the <code>CorC</code> folder.</p> <p>Problem: Some library file or package that is in the git is not shown locally in eclipse and there are errors missing that file</p> <p>Solution: Press <code>F5</code> when hovering over the parent directory of the missing file. The file should appear.</p>"},{"location":"corc/information-flow/","title":"Information flow","text":""},{"location":"corc/information-flow/#information-flow","title":"Information Flow","text":"<p>The CorC ecosystem supports the definition of information flow policies and provides an extension to create programs that comply to these policies by construction.</p> <p>To use the information flow functionally, you can create new secure variables by adding <code>Variables</code> and <code>Variable</code> from the <code>Palette</code>, and using these variables in the program. For example, a private variable x can be introduced by writing private in the Confidentiality column.</p>"},{"location":"corc/mutation/","title":"Mutation","text":""},{"location":"corc/mutation/#mutation-generation","title":"Mutation Generation","text":"<p>The mutation feature allows the mutation of refinements that contain Java code with MuJava. Furthermore, mutating conditions via a separate mutation module that does not use MuJava is possible. Every mutant is generated as a new CbC program and can be found inside the <code>mutations</code> folder inside the project. Resulting CbC programs are not guaranteed to be correct according to their specification.</p>"},{"location":"corc/mutation/#code-mutation","title":"Code Mutation","text":"<p>To mutate any applicable refinement rule inside CorC, proceed as follows: 1. Select the refinement rule. 2. Navigate to the 'Mutations' in the properties window. 3. Select the desired mutation operators and press the mutate button.</p> <p>Code Mutation Example</p> <p>Suppose the statement <code>i = i + 1;</code> is part of a CbC program in CorC. Some possible mutations for this statement are: - <code>i = i - 1;</code> - <code>i = i * 1;</code> - <code>i = i / 1;</code> - <code>i = i % 1;</code></p>"},{"location":"corc/mutation/#condition-mutation","title":"Condition Mutation","text":"<p>To mutate conditions follow: 1. Select a condition. 2. Navigate to the 'Mutations' in the properties window. 3. Select the desired mutation operators and press the mutate button.</p> <p>Condition Mutation Example</p> <p>Given the condition <code>i &gt; 0 -&gt; TRUE</code>, some possible mutations are the following - <code>i &gt;= 0 -&gt; TRUE</code> - <code>i &lt; 0 -&gt; TRUE</code> - <code>i == 0 -&gt; TRUE</code> - <code>i != 0 -&gt; TRUE</code></p>"},{"location":"corc/project-types/","title":"Project Types","text":"<p>CorC currently supports three different project types: Non-object-oriented projects, object-oriented projects, and software product lines.</p>"},{"location":"corc/project-types/#non-object-oriented-projects","title":"Non-object Oriented Projects","text":"<p>A non-object-oriented project contains not classes but a finite number of CbC methods. This project type helps create small programs. 1. Create a new Java project. 2. Create a folder named <code>src</code>. 3. Handle any CbC program inside the <code>src</code> folder.</p> <p>[[https://github.com/KIT-TVA/CorC/blob/master/Wiki/corc-example-project-structure.png]]</p>"},{"location":"corc/project-types/#object-oriented-projects","title":"Object-Oriented Projects","text":"<p>Object-oriented projects are based on CbC classes and CbC methods. We may create a CbC class diagram via the file wizard. Upon creation we'll find a new <code>.cbcclass</code> file in the project. CbC class diagrams essentially depict a high-level view of the class, its fields, and methods. CbC class diagrams are internally linked to their respective CbC method diagrams, identified through the <code>.cbcdiagram</code> file type, so any variable changes are automatically adjusted in the CbC classes and CbC methods. CbC classes must reside in a folder with the same name. CbC methods reside in the same folder as their respective class. 1. Create a new Java project. 2. Create a folder named <code>src</code>. 3. Create a folder with the name of some class <code>A</code> inside <code>src</code>. 4. Create a CbC class named <code>A</code> inside folder <code>A</code>. 5. Insert CbC methods belonging to class <code>A</code> in folder <code>A</code>. (TODO: Example here.)</p> <p>[[https://github.com/KIT-TVA/CorC/blob/master/Wiki/oo-structure.png]]</p>"},{"location":"corc/project-types/#software-product-lines","title":"Software Product Lines","text":"<p>We may implement software product lines (SPL) in CorC. The project structure for SPLs requires additional information about their features and underlying feature model, which is given through a model description file. 1. Create a new Java project. 2. Create a folder named <code>src</code>. 3. Define a model description file <code>model.xml</code> and place it inside the java project. 4. Create one folder for every feature in the model and place them inside folder <code>src</code>. 5. Place any CbC classes and methods inside their respective feature folder according to the principles of object-oriented projects.</p> <p>[[https://github.com/KIT-TVA/CorC/blob/master/Wiki/spl-structure.png]]</p>"},{"location":"corc/proof-stats/","title":"Proof stats","text":""},{"location":"corc/proof-stats/#proof-statistics","title":"Proof Statistics","text":"<p>Statistics like execution time, proof status, number of branches, and more can be summarized and visualized with the proof statistic extension. To show proof statistics for a single CbC program: <code>Right-click the diagram -&gt; View CorC Statistics</code>. Furthermore, CorC provides diagrams for the average execution time and the time per configuration in SPLs if multiple CbC programs are selected. These diagrams are shown at the bottom of the <code>Statistics Viewer</code>. Note that the diagrams are generated by R. Therefore, we must install and add it to the environment variable PATH to view proof statistic diagrams.</p> <p>[[https://github.com/KIT-TVA/CorC/blob/master/Wiki/proof-statistics.png]]</p>"},{"location":"corc/related-work/","title":"Related work","text":""},{"location":"corc/related-work/#archicorc","title":"ArchiCorC","text":"<p>ArchiCorC is a separate software system that interfaces with CorC for Component-based software engineering with CbC. </p>"},{"location":"corc/testing/","title":"Testing","text":""},{"location":"corc/testing/#test-case-generation","title":"Test Case Generation","text":"<p>The CorC ecosystem includes a test generation extension that generates test cases for single refinements of CbC programs. Depending on the program's complexity, we may provide custom input values for the supported data types through the <code>Testing</code> tab in the Eclipse property view. The extension also supports automatic input generation, either by use of default values for data types or through SMT solving with the Z3 SMT-solver. After the generation of test cases, the extension uses TestNG to execute those test cases. Successfully tested refinements will be highlighted in orange in the graphical editor. Furthermore, the console outputs testing status information. If a test case fails, the console will provide the user with detailed error information, and the corresponding refinement will be changed to red in the graphical editor. This extension is also available in the LOST-Editor. Test one or more refinements in the graphical editor by: 1. Configure the test case generation extension through the <code>Properties -&gt; Testing</code> tab. 2. Right-click a refinement or anywhere else in a CbC method diagram. 3. Select <code>Test</code> and a suitable testing option. 4. (Optional) Navigate to the <code>Console</code> tab to view status information during and after testing. [[https://github.com/KIT-TVA/CorC/blob/master/Wiki/testing-window.png]]</p>"},{"location":"corc/verification/","title":"\u2705 Verification","text":"<p>Verifying entire CbC programs and the application of refinement rules in CorC is possible through the deductive verifier KeY. There are two ways to verify CbC programs in CorC: through the graphical editor and the textual editor. The verification process is identical for both extensions. Once the verification process is started, CorC generates proof obligations for KeY in <code>.key</code> files found in the current project folder. Every time KeY provides output, CorC shows status information depending on the response from KeY. Afterwards, the verification results are saved in <code>.proof</code> files next to their corresponding <code>.key</code> files. All successfully verified refinements are highlighted in green in the graphical editor if the verification was successful. If the proof for a refinement rule cannot be closed, CorC will highlight the refinement in red.</p>"},{"location":"corc/verification/#verification-in-the-graphical-editor","title":"\ud83d\uddbc\ufe0f Verification in the Graphical Editor","text":"<ul> <li>Open the console property view through <code>Window -&gt; Show View -&gt; Console</code> to monitor the verification process.</li> </ul> <p>Verifying all refinements: 1. Right-click anywhere in a CbC diagram. 2. Select <code>Verify -&gt; Verify All Statements</code>.</p> <p>Verifying single refinements: 1. Right-click on any refinement. 2. Select <code>Verify -&gt; Verify a statement</code>.</p>"},{"location":"corc/verification/#verification-in-the-textual-editor","title":"\ud83d\uddba Verification in the Textual Editor","text":"<ol> <li>Open the console property view through <code>Window -&gt; Show View -&gt; Console</code> to monitor the verification process.</li> <li>Open the LOST-editor.</li> <li>Press the button <code>Load</code>.</li> <li>Press the button <code>Verify</code>.</li> </ol>"},{"location":"home/contact/","title":"\u2709\ufe0f Contact","text":"<p>If you have questions, feedback, or discover a bug in our tool, we\u2019d love to hear from you. Your insights help us improve and keep things running smoothly.  </p> <p>Contact us: corc@kastel.kit.edu</p>"},{"location":"home/contact/#chair-of-test-validation-and-analysis-of-software-intensive-systems-tva","title":"\ud83e\ude91 Chair of Test, Validation and Analysis of Software-Intensive Systems (TVA)","text":"<p>Head: Prof. Dr.-Ing. Ina Schaefer  </p> <p>Address: Am Fasanengarten 5 Building 50.34 (Room 369) 76131 Karlsruhe Germany</p>"},{"location":"home/contact/#karlsruhe-institute-of-technology-kit","title":"\ud83c\udfe2 Karlsruhe Institute of Technology (KIT)","text":"<p>Address: Karlsruhe Institute of Technology (KIT) Kaiserstra\u00dfe 12 76131 Karlsruhe Germany</p>"},{"location":"home/members/","title":"\ud83e\uddd1\u200d\ud83d\udcbb People","text":"<p>The CorC universe is developed by the chair for Test, Validation and Analysis of Software-Intensive Systems at Karlsruhe Institute of Technology (KIT) led by Prof. Dr.-Ing. Ina Schaefer.</p> Name Position Email Prof. Dr.-Ing. Ina Schaefer Head ina.schaefer@kit.edu M. Sc. Tabea Bordis Researcher tabea.bordis@kit.edu M. Sc. Fynn Demmler Researcher fynn.demmler@kit.edu M. Sc. Maximilian Kodetzki Researcher kodetzki@kit.edu B. Sc. Markus Flaschentr\u00e4ger Student Employee markus.flaschentraeger@gmx.de Ci\u00e1n Payne Student Employee uezbf@student.kit.edu B. Sc. Jafer Sharfeddin Student Employee jafer.shar@gmail.com"},{"location":"home/members/#alumni","title":"\ud83e\uddd3 Alumni","text":"<p>Previous researchers that worked in the CorC universe.</p> Name Dr.-Ing. Alexander Kittelmann Dr.-Ing. Tobias Runge"},{"location":"home/pubs/","title":"\ud83d\udcda Publications","text":"<p>Welcome to the publications list. FInd selected publicaions below and the full list of publications on CbC, XbC, and CorC at the bottom of this page.</p>"},{"location":"home/pubs/#selected-publications","title":"\ud83c\udf1f Selected Publications","text":"<ul> <li>T. Bordis, M. Kodetzki, and I. Schaefer. From Concept to Reality: Leveraging Correctness-by-Construction for Better Algorithm Design. IEEE Computer 57/7. 2024.</li> <li>T. Runge, I. Schaefer, L. Cleophas, T. Th\u00fcm, D. G. Kourie, and B. W. Watson. Tool Support for Correctness-by-Construction. FASE 2019.</li> </ul>"},{"location":"home/pubs/#all-publications","title":"\ud83d\udcd6 All Publications","text":"<p>The list of publications is grouped by publication year.</p>"},{"location":"home/pubs/#2025","title":"\ud83d\udcc5 2025","text":"<ul> <li>M. Kodetzki. X-by-Construction: Unifying Functional Correctness and Non-Functional Guarantees. ISSRE Workshops 2025.</li> <li>M. Kodetzki, T. Bordis, A. Potanin, and I. Schaefer. X-by-Construction: Towards Ensuring Non-Functional Properties in by-Construction Engineering. Onward! Papers (SPLASH) 2025.</li> <li>T. Bordis. Scaling Correcness-by-Construction. Dissertation. 2025.</li> <li>R. R\u00f8nneberg, T. Bordis, C. Gerking, A. Heydari Tabar, and I. Schaefer. Scaling Information Flow Control By-Construction to Component-Based Software Architectures. FORTE 2025.</li> </ul>"},{"location":"home/pubs/#2024","title":"\ud83d\udcc5 2024","text":"<ul> <li>M. Kodetzki, T. Bordis, M. Kirsten, and I. Schaefer. Towards AI-Assisted Correctness-by-Construction Software Development. ISoLA 2024.</li> <li>T. Bordis, M. Kodetzki, and I. Schaefer. From Concept to Reality: Leveraging Correctness-by-Construction for Better Algorithm Design. IEEE Computer 57/7. 2024.</li> <li>M. Kodetzki, T. Bordis, T. Runge, and I. Schaefer. Partial Proofs to Optimize Deductive Verification of Feature-Oriented Software Product Lines. VaMoS 2024.</li> </ul>"},{"location":"home/pubs/#2023","title":"\ud83d\udcc5 2023","text":"<ul> <li>T. Runge, T. Bordis, A. Potanin, T. Th\u00fcm, and I. Schaefer. Flexible Correct-by-Construction Programming. Logical Methods in Computer Science, Volume 19. 2023.</li> <li>T. Runge. Correctness-by-Construction for Correct and Secure Software Systems. Dissertation. 2023.</li> <li>T. Runge, M. Servetto, A. Potanin, and I. Schaefer. Immutability and Encapsulation for Sound OO Information Flow Control. ACM Transactions on Programming Languages and Systems, Volume 45. 2023.</li> </ul>"},{"location":"home/pubs/#2022","title":"\ud83d\udcc5 2022","text":"<ul> <li>T. Runge, A. Potanin, T. Th\u00fcm, and I. Schaefer. Traits for Correct-by-Construction Programming. CoRR 2022.</li> <li>T. Bordis, T. Runge, D. Schultz, and I.Schaefer. Family-Based and Product-Based Development of Correct-by-Construction Software Product Lines. Journal of Computer Languages (COLA). 2022.</li> <li>T. Bordis, L. Cleophas, A. Kittelmann, T. Runge, I. Schaefer, and B. W. Watson. Re-CorC-ing KeY: Correct-by-Construction Software Development Based on KeY. The Logic of Software: A Tasting Menu of Formal Methods. 2022.</li> <li>T. Runge, A. Potanin, T. Th\u00fcm, and I. Schaefer. Traits: Correctness-by-Construction for Free. FORTE 2022.</li> <li>A. Kittelmann, T. Runge, T. Bordis, and I. Schaefer. Runtime Verification of Correct-by-Construction Driving Maneuvers. ISoLA 2022.</li> <li>T. Bordis, M. Kodetzki, T. Runge, and I. Schaefer. VarCorC: Developing Object-Oriented Software Product Lines Using Correctness-by-Construction. SEFM 2022.</li> <li>T. Runge, A. Kittelmann, M. Servetto, A. Potanin, and I. Schaefer. Information Flow Control-by-Construction for an Object-Oriented Language. SEFM 2022.</li> </ul>"},{"location":"home/pubs/#2021","title":"\ud83d\udcc5 2021","text":"<ul> <li>I. Schaefer, T. Runge, L. Cleophas, and B. W. Watson. Tutorial: The Correctness-by-Construction Approach to Programming Using CorC. SecDev 2021.</li> <li>T. Runge, T. Bordis, T. Th\u00fcm, and I. Schaefer. Teaching Correctness-by-Construction and Post-hoc Verification - The Online Experience. FMTea 2021.</li> </ul>"},{"location":"home/pubs/#2020","title":"\ud83d\udcc5 2020","text":"<ul> <li>T. Bordis, T. Runge, and I. Schaefer. Correctness-by-Construction for Feature-Oriented Software Product Lines. GPCE 2020.</li> <li>T. Runge, A. Kn\u00fcppel, T. Th\u00fcm, and I. Schaefer. Lattice-Based Information Flow Control-by-Construction for Security-by-Design. FormaliSE 2020.</li> <li>A. Kn\u00fcppel, T. Runge, and I. Schaefer. Scaling Correctness-by-Construction. ISoLA 2020.</li> <li>T. Bordis, T. Runge, A. Kn\u00fcppel, T. Th\u00fcm, and I. Schaefer. Variational Correctness-by-Construction. VaMoS 2020.</li> </ul>"},{"location":"home/pubs/#2019","title":"\ud83d\udcc5 2019","text":"<ul> <li>T. Runge, T. Th\u00fcm, L. Cleophas, I. Schaefer, and B. W. Watson. Comparing Correctness-by-Construction with Post-Hoc Verification - A Qualitative User Study. REFINE 2019.</li> <li>T. Runge, I. Schaefer, L. Cleophas, T. Th\u00fcm, D. G. Kourie, and B. W. Watson. Tool Support for Correctness-by-Construction. FASE 2019.</li> </ul>"},{"location":"home/pubs/#2018","title":"\ud83d\udcc5 2018","text":"<ul> <li>I. Schaefer, T. Runge, A. Kn\u00fcppel, L. Cleophas, D. G. Kourie, and B. W. Watson. Towards Confidentiality-by-Construction. ISoLA 2018.</li> </ul>"},{"location":"theory/cbc/example/","title":"Practical Example","text":""},{"location":"theory/cbc/example/#corc-refinement-rules","title":"CorC Refinement Rules","text":"<p>CorC's refinement rules build a superset of CbC's refinement rules. Additional refinement rules are:</p> <ul> <li> <p>Original Call | Call the method with the same signature from the parent feature in a SPL.</p> </li> <li> <p>Return Assignment | Automatically sets the return variable <code>ret</code> to the expression returned inside this assignment.</p> </li> </ul>"},{"location":"theory/cbc/example/#cbc-example","title":"CbC Example","text":"<p>Since the introduction is somewhat abstract, we examine how CbC works in a simple example. We want to create a program that returns <code>TRUE</code>, iff some natural number <code>n</code> is even, else it returns <code>FALSE</code>. We will store the return value in a boolean variable <code>ret</code>. Given the abstract hoare triple</p> <p><code>{P} S {Q}</code>,</p> <p>we define pre condition <code>P := n &gt; 0</code>. That is, we require the number <code>n</code> to be bigger than <code>0</code>, which must be ensured by the callee. Consequently, the program must ensure the following postcondition <code>Q := (n % 2 == 0 -&gt; ret = TRUE) &amp; (n % 2 != 0 -&gt; ret = FALSE)</code> after execution. We now decide to use the selection refinement rule, which is similar to branching in Java to refine the abstract hoare triple into a new refinement:</p> <pre><code>{P} S {Q} \n\u2291 {P} if G1 -&gt; S1 elseif G2 -&gt; S2 {Q}\n</code></pre> <p>As we can see, there are some new conditions <code>G1, G2</code>, called guards, and abstract statements <code>S1, S2</code>.  Guards <code>G</code> and <code>G2</code> are the required side conditions for the selection refinement for our example.  As we will see, statements <code>S1</code> and <code>S2</code> can be further refined separately.  Since we want to differentiate between the number <code>n</code> being even <code>n % 2 = 0</code> and uneven <code>n % 2 != 0</code>, we use these as guards <code>G1 := n % 2 = 0</code> and <code>G2 := n % 2 != 0</code>.</p> <p>Lastly, we need to refine statements <code>S1</code> and <code>S2</code>. We use the statement refinement rule for both:</p> <pre><code>{P} S {Q} \n\u2291 {P} if G1 -&gt; S1 elseif G2 -&gt; S2 {Q}\n\u2291 {P} if G1 -&gt; TRUE elseif G2 -&gt; S2 {Q}\n\u2291 {P} if G1 -&gt; TRUE elseif G2 -&gt; FALSE {Q}\n</code></pre> <p>with</p> <pre><code>P := n &gt; 0\nQ := (n % 2 = 0 -&gt; ret = TRUE) &amp; (n % 2 != 0 -&gt; ret = FALSE)\nG1 := n % 2 = 0\nG2 := n % 2 != 0\n</code></pre> <p>We have created a fully specified CbC program that can be verified with a deductive verifier like KeY. One of the main benefits of this approach compared to post-hoc verification is that we can also verify every refinement step independently, which is challenging with post-hoc verification.</p> <p>//TODO THIS IS ECLIPSE</p>"},{"location":"theory/cbc/example/#corc-example","title":"CorC Example","text":"<p>Let us consider the program from the CbC Example section. We want to implement that program in CorC.</p> <ol> <li>Create a new Java Project: <code>File -&gt; New -&gt; Project... -&gt; Java Project</code>.</li> <li>Create a folder named <code>isEven</code> inside the folder <code>src</code>.</li> <li>Create a new CorC diagram: <code>Right-click -&gt; New -&gt; Other... -&gt; new CorC File</code>. We name it <code>isEven</code>: [[https://github.com/KIT-TVA/CorC/blob/master/Wiki/corc-example-project-structure.png]]</li> <li>Now we start creating the CbC program. We introduced the <code>Formula f</code> including it's pre- and postcondition and the variables <code>boolean ret</code> and <code>int n</code> inside the <code>Variables</code> block using drag-and-drop from the <code>Palette</code>. [[https://github.com/KIT-TVA/CorC/blob/master/Wiki/corc-example-formula.png]]</li> <li>We now introduce a <code>SelectionStatement s</code> and add another guard by drag-and-dropping an <code>ExtraSelection</code> onto the selection <code>s</code>. We also connect the abstract hoare triple <code>f</code> with selection <code>s</code> using the <code>Refinement</code> connection. [[https://github.com/KIT-TVA/CorC/blob/master/Wiki/corc-example-selection.png]]</li> <li>Finally, we add two return assignments <code>ReturnStatement</code> and connect them to the selection <code>s</code>. [[https://github.com/KIT-TVA/CorC/blob/master/Wiki/corc-example-full.png]]</li> <li>We now verify the entire CbC program or each refinement rule separately through the context menu. [[https://github.com/KIT-TVA/CorC/blob/master/Wiki/corc-example-verified.png]]</li> <li>To convert the method <code>isEven</code> into Java code, we click <code>Generate Code</code> in the context menu. [[https://github.com/KIT-TVA/CorC/blob/master/Wiki/code-gen.png]]]</li> </ol>"},{"location":"theory/cbc/theory/","title":"\ud83c\udfd7\ufe0f Correctness-by-Construction","text":"<p>Implementing a program using Correctness-by-Construction (CbC) starts with an abstract hoare triple {P} S {Q} where symbols P and Q are the pre- and postcondition of the program to be constructed, and symbol S represents the implementation abstractly. Given a set of refinement rules, we can refine the abstract program S iteratively to concrete code. Certain refinement rules require further specifications to be defined, e.g., loop invariants or intermediate conditions.</p> <p>Each refinement rule comes with (a set of) side conditions that need to be met to be applicable at a certain point in a program. These side conditions can be proven and guarantee functional correctness once verified.</p>"},{"location":"theory/cbc/theory/#refinement-rules","title":"\u21aa\ufe0f Refinement Rules","text":"<p>Below, we show the basic set of refinement rules supported by the CorC ecosystem. We provide the examplary construction of a program using CbC here.</p> <ul> <li>Skip | {P} skip {Q} iff P implies Q     The skip rule can be applied if precondition P is fulfilled as soon as postcondition Q is fulfilled. The abstract statement S can be refined to skip and does not change the state of the program.</li> <li>Assignment | {P} x := E {Q} iff P implies Q[x\\E]     Using the assignment rule, an expression E of type T can be assigned to a variable x of the same type T. An abstract statement S can be refined to the assignment x:=E if precondition P implies postcondition Q and every occurrence of variable x in postcondition P is replaced by expression E.    </li> <li>Composition | {P} S<sub>1</sub> ; S<sub>2</sub> {Q} iff there is an intermediate condition M such that {P} S<sub>1</sub> {M} and {M} S<sub>2</sub> {Q}     Using the composition rule, it is possible to split an abstract statement S into two abstract statements S<sub>1</sub> and S<sub>2</sub>. To do so, an intermediate condition M has to be introduced. Condition M has to be fulfilled after executing the abstract statement S<sub>1</sub> and before executing the abstract statement S<sub>2</sub>. With this, the intermediate condition M has to be stronger than precondition P and weaker than postcondition Q.</li> <li>Selection | {P} if G<sub>1</sub> \u2192 S1 elseif . . . G<sub>n</sub> \u2192 S<sub>n</sub> fi {Q} iff (P implies G<sub>1</sub> \u2228 G<sub>2</sub> \u2228 . . . \u2228 G<sub>n</sub>) and {P \u2227 G<sub>i</sub>} S<sub>i</sub> {Q} holds for all i*     The selection rule can be used to refine the abstract statement S into various cases. Every case is indicated by a guard G<sub>i</sub>. The Hoare-triples of the different cases consist of the precondition P \u2227 G<sub>i</sub>, the refined abstract statement S<sub>i</sub>, and the postcondition Q. The statement whose guard is fulfilled first is called.</li> <li>Repetition | {P} do [I, V] G \u2192 S od {Q} iff (P implies I) and (I \u2227 \u00acG implies Q) and {I \u2227 G \u2227 V=V<sub>0</sub>} S {I \u2227 0 \u2264 V \u2227 V &lt; V<sub>0</sub>} and {I \u2227 G} S {I}     The repetition rule works similar to a while-loop known from different programming languages. As long as guard G is evaluated to true, the loop statement S is executed. A set of conditions has to be fulfilled to be able to apply the repetition rule: Loop invariant I has to be implied by precondition P. The conjunction of the invariant I and the negated guard G have to imply postcondition Q. The loop statement S has to preserve the invariant I. With showing that variant V is monotonically decreasing and has zero as lower bound, the termination of the loop is guaranteed.</li> <li>Method Call | If {P} \u2192 {P'}[p<sub>i</sub>\\a<sub>i</sub>] and Q'[p<sub>i</sub><sup>old</sup>\\a<sub>i</sub><sup>old</sup>, r\\b] \u2192 Q then {P} S {Q} can be refined to {P} M(a<sub>1</sub>, ..., a<sub>n</sub>, b) {Q} with the method {P'} M(param p<sub>1</sub>, ..., param p<sub>n</sub>, return r) {Q'}. Using the method-call rule, it is possible to implement call-by-value method-calls. For this, a method M can be called with an optional set of parameters. The parameters ai and the variable b which is reserved for the return value, represent the current values and can be used in the conditions P and Q. The formal parameters p<sub>i</sub> and r can be part of the precondition P'. They are set to the corresponding parameters a<sub>i</sub> and b when calling the method. To access the variables' values prior the execution of the called method in the postcondition Q', the parameters can be annotated with a superscripted old.</li> </ul> <p>The set of basic refinement rules is extended by tool-specific rules. Original- and variational method call rule belong to concepts of software product lines, which are explained in more detail here.</p>"}]}